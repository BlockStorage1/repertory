#!groovy

pipeline {
  agent none

  environment {
    DEVELOPER_PRIVATE_KEY = "/.ci/repertory/cert/developer.priv"
    DEVELOPER_PUBLIC_KEY  = "/.ci/repertory/cert/developer.pub"
    PROJECT_TEST_CONFIG_DIR = "/.ci/repertory/test"
  }

  options {
    disableConcurrentBuilds()
    skipDefaultCheckout()
    timestamps()
  }

  stages {
    stage('Build • Test • Deliver') {
      agent any
      stages {
        stage('Checkout') {
          steps {
            script {
              int maxAttempts = 6
              int baseDelay  = 10
              for (int attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                  checkout scm
                  break
                } catch (err) {
                  if (attempt == maxAttempts) { throw err }
                  int waitSec = baseDelay * (1 << (attempt - 1))
                  echo "Checkout failed (attempt ${attempt}/${maxAttempts}). Waiting ${waitSec}s before retry..."
                  sleep time: waitSec, unit: 'SECONDS'
                }
              }
            }
          }
        }

        stage('linux_x86_64') {
          steps {
            script { retryWithBackoff(2, 5) { sh 'scripts/make_unix.sh' } }
          }
        }

        stage('mingw64') {
          steps {
            script { retryWithBackoff(2, 5) { sh 'scripts/make_win32.sh' } }
          }
        }

        stage('linux_aarch64') {
          steps {
            script { retryWithBackoff(2, 5) { sh 'scripts/make_unix.sh aarch64' } }
          }
        }

        stage('linux_x86_64_test') {
          steps {
            script { retryWithBackoff(2, 5) { sh 'scripts/run_tests.sh' } }
          }
        }

        stage('deliver') {
          steps {
            script {
              retryWithBackoff(3, 10) { sh 'scripts/deliver.sh /mnt/repertory "" "" "" "" 1 1' }
              retryWithBackoff(3, 10) { sh 'scripts/deliver.sh /mnt/repertory "" aarch64' }
              retryWithBackoff(3, 10) { sh 'scripts/deliver.sh /mnt/repertory' }
            }
          }
        }
      }
    }
  }
}

def retryWithBackoff(int maxAttempts, int baseDelaySeconds, Closure body) {
  for (int attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      body()
      return
    } catch (err) {
      if (attempt == maxAttempts) { throw err }
      int waitSec = baseDelaySeconds * (1 << (attempt - 1))
      echo "Step failed (attempt ${attempt}/${maxAttempts}). Waiting ${waitSec}s before retry..."
      sleep time: waitSec, unit: 'SECONDS'
    }
  }
}
