#!groovy

pipeline {
  agent none

  environment {
    DEVELOPER_PRIVATE_KEY   = "${env.HOME}/.ci/repertory/cert/developer.priv"
    DEVELOPER_PUBLIC_KEY    = "${env.HOME}/.ci/repertory/cert/developer.pub"
    PROJECT_TEST_CONFIG_DIR = "${env.HOME}/.ci/repertory/test"
  }

  options {
    disableConcurrentBuilds()
    skipDefaultCheckout()
    timestamps()
  }

  stages {
    stage('Build • Test • Deliver') {
      agent any
      stages {
        stage('Checkout') {
          steps {
            script {
              int maxAttempts = 6
              int baseDelay   = 10
              for (int attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                  checkout scm
                  break
                } catch (err) {
                  if (attempt == maxAttempts) { throw err }
                  int waitSec = baseDelay * (1 << (attempt - 1))
                  echo "Checkout failed (attempt ${attempt}/${maxAttempts}). Waiting ${waitSec}s before retry..."
                  sleep time: waitSec, unit: 'SECONDS'
                }
              }
            }
          }
        }

        stage('darwin_aarch64') {
          steps { script { retryWithBackoff(2, 5) { sh 'scripts/make_unix.sh aarch64' } } }
        }

        stage('darwin_x86_64') {
          steps { script { retryWithBackoff(2, 5) { sh 'scripts/make_unix.sh x86_64' } } }
        }

        stage('darwin_aarch64_test') {
          steps { script { retryWithBackoff(2, 5) { sh 'scripts/run_tests.sh aarch64' } } }
        }

        stage('deliver') {
          steps {
            script {
              retryWithBackoff(3, 10) { sh "scripts/deliver.sh ${env.HOME}/mnt/repertory '' aarch64" }
              retryWithBackoff(3, 10) { sh "scripts/deliver.sh ${env.HOME}/mnt/repertory '' x86_64" }
            }
          }
        }
      }
    }
  }
}

def retryWithBackoff(int maxAttempts, int baseDelaySeconds, Closure body) {
  for (int attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      body()
      return
    } catch (err) {
      if (attempt == maxAttempts) { throw err }
      int waitSec = baseDelaySeconds * (1 << (attempt - 1))
      echo "Step failed (attempt ${attempt}/${maxAttempts}). Waiting ${waitSec}s before retry..."
      sleep time: waitSec, unit: 'SECONDS'
    }
  }
}
